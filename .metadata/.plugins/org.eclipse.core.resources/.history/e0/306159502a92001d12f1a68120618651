/*
 * stm32f407xx_gpio_driver.c
 *
 *  Created on: Jan 9, 2023
 *      Author: tomed
 */


#include "stm32f407xx_spi_driver.h"

/*********************************************************************
 * @fn      		  - SPI_PeriClockControl
 *
 * @brief             - This function enables or disables peripheral clock for the given GPIO port
 *
 * @param[in]         - base address of the SPI peripheral
 * @param[in]         - ENABLE or DISABLE macros
 * @param[in]         -
 *
 * @return            -  none
 *
 * @Note              -none
 *********************************************************************/

void SPI_PeriClockControl(SPI_RegDef_t *pSPIx, uint8_t EnorDi)
{
	if(EnorDi == ENABLE)
		{
			//Enables the clock for the given SPI peripheal
			if(pSPIx == SPI1)
			{
				SPI1_PCLK_EN();
			}else if (pSPIx == SPI2)
			{
				SPI2_PCLK_EN();
			}else if (pSPIx == SPI3)
			{
				SPI3_PCLK_EN();
			}
		}
}

/*********************************************************************
 * @fn      		  - SPI_Init
 *
 * @brief             - Initalize a given SPI port for use
 *
 * @param[in]         - spi config structure
 * @param[in]         -
 * @param[in]         -
 *
 * @return            -  none
 *
 * @Note              -none
 *********************************************************************/


void SPI_Init(SPI_Handle_t *pSPIHandle)
{
	//First the SPI_CR1 is configured
	//As a large amount of bits need to be set a temp register is used. This will then be copied into the actual register.
	uint16_t tempReg = 0;

	//Configure the device mode mater or slave
	tempReg |= pSPIHandle->SPIConfig.SPI_DeviceMode << 2;

	//Configure the bus config
	if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_FD)
	{
		//Enable BIDI by clearing bit
		tempReg &= ~(1 << SPI_CR1_BIDIMODE);

	}else if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_HD)
	{
		//Disable BIDI by setting bit
		tempReg |= (1 << SPI_CR1_BIDIMODE);
	}
	else if(pSPIHandle->SPIConfig.SPI_BusConfig == SPI_BUS_CONFIG_SIMPLEX_RXONLY)
	{
		//Enable BIDI by clearing bit and set RX only for recieve only
		tempReg &= ~(1 << SPI_CR1_BIDIMODE);
		tempReg |= (1 << SPI_CR1_RXONLY);
	}

	//Set the SCLK divisor
	tempReg |= pSPIHandle->SPIConfig.SPI_SclkSpeed << SPI_CR1_BR;

	//Set the DFF
	tempReg |= pSPIHandle->SPIConfig.SPI_DFF<< SPI_CR1_DFF;

	//Set the CPOL
	tempReg |= pSPIHandle->SPIConfig.SPI_CPOL<< SPI_CR1_CPOL;

	//Set the CPHA
	tempReg |= pSPIHandle->SPIConfig.SPI_CPHA<< SPI_CR1_CPHA;

	//Set the SSM
	tempReg |= pSPIHandle->SPIConfig.SPI_SSM<< SPI_CR1_SSM;

	pSPIHandle->pSPIx->CR1 = tempReg;


}

/*********************************************************************
 * @fn      		  - SPI_DeInit
 *
 * @brief             - Clears the SPI peripheal register
 *
 * @param[in]         - spi port
 * @param[in]         -
 * @param[in]         -
 *
 * @return            -  none
 *
 * @Note              -none
 *********************************************************************/
void SPI_DeInit(SPI_RegDef_t *pSPIx)
{
	//Enables the clock for the given SPI peripheal
	if(pSPIx == SPI1)
	{
		SPI1_REG_RESET();
	}else if (pSPIx == SPI2)
	{
		SPI2_REG_RESET();
	}else if (pSPIx == SPI3)
	{
		SPI2_REG_RESET();
	}
}

void SPI_SendData(SPI_RegDef_t *pSPIx, uint8_t* data,uint32_t Len)
{
	while(Len > 0)
	{
		//Check if the Tx buffer is empty
	}

}
